#ifndef _TEST_H
#define _TEST_H

//There are 4 possible states(S), and 3 observation types(V)
#define S_DEF 4
#define V_DEF 3
#define N_OBS_TAKEN 20
//A type definition for the HMM struct
typedef struct {
	int S;
	int V;
	float transition[S_DEF][S_DEF];
	float emission[S_DEF][V_DEF];
	float prior[S_DEF];
} hmm_desc;

hmm_desc hmm1 = {S_DEF, V_DEF,

{
	{0.09,0.9,0.01,0},
	{0.09,0.01,0.9,0},
	{0.09,0.45,0.01,0.45},
	{0.5,0.5,0,0}
},

{
	{1,0,0},
	{0,1,0},
	{0,0,1},
	{0,1,0}
},

{0.25,0.25,0.25,0.25}
};

// Test case 1.2
hmm_desc hmm2 = {S_DEF, V_DEF, 
{
	{0.1,0.4,0.1,0.4},
	{0.1,0.2,0.35,0.35},
	{0.1,0.2,0.25,0.45},
	{0.25,0.5,0.1,0.25}
},
{
	{0.4,0.5,0.1},
	{0.2,0.5,0.3},
	{0.2,0.2,0.6},
	{0.1,0.8,0.1}
},

{0.25,0.25,0.25,0.25}
};

// Test case 1.3
hmm_desc hmm3 = {S_DEF, V_DEF, 
{
	{0.09,0.9,0.01,0},
	{0.09,0.01,0.9,0},
	{0.09,0.45,0.01,0.45},
	{0.5,0.5,0,0}
},
{
	{0,0.5,0.5},
	{0,1,0},
	{0,0,1},
	{0,1,0}
},
	{0.25,0.25,0.25,0.25}
};

int nobs = 20;
//This is the array of observations (same for all three hmm structs)
//int vitTestArray[20] = {2,1,1,2,1,2,1,0,1,2,1,1,2,1,2,1,1,2,1,0};
int obs[20] = {2,1,1,2,1,2,1,0,1,2,1,1,2,1,2,1,1,2,1,0};
//The number of observations


//This is the array with which you should compare the EstimatedStates array generated by your method (different for each hmm struct)
int vit_path_1[20] = {2,3,1,2,1,2,3,0,1,2,3,1,2,1,2,3,1,2,3,0};
int vit_path_2[20] = {2,3,1,2,3,1,3,0,1,2,3,1,2,3,1,3,1,2,3,0};
//The Viterbi algorithm should not be able to produce a path with the third hmm struct

//You will be given an array of floating point values accObs along with the number of elements in it accT
int accT = 45;
float accObs[45] = 
{-0.47, 0.51, 0.69, 0.02, 0.54, 0.12, -0.48, 0.42, 3.73, 
 6.19, 6.74, 6.49, -5.71, -4.15, -7.35, -7.20, -7.02, -3.11,
 4.37, 2.17, 4.36, 1.86, -0.62, 0.49, 0.08, 0.60, 0.27, 
 0.12, 6.67, 7.13, 7.92, 0.80, -1.77, -3.59, -0.87, 4.60, 
 4.25, 6.57, 2.44, 0.03, 0.56, 0.10, 0.48, 0.33, 0.12};

//And the threshold values 
float alpha1 = 0.7;
float alpha2 = 0.8;
int N[3] = {3, 3, 3};

//Using this information your method should produce the following observation sequence and number of observations
int Y[9] = {0,1,2,1,0,1,2,1,0};
int Ynobs = 9;

//Finally, after verifying that the generated observation sequence is correct
//it should be used in your Viterbi code along with the previously provided hmm struct hmm1
//to generate an EstimatedStates array that matches the given expected output:
int X[9] = {0,1,2,3,0,1,2,3,0};




// Input for Part I and II Viterbi Update

// Use with hmm1
//float InputArray_1[2*S_DEF] = {0.0f, 0.5f, 0.0f, 0.5f, 0.0f, 2.0f, 0.0f, 3.0f};
float InputArray_1[2*S_DEF] = {0.0f, 0.0f, 0.5f, 2.0f, 0.0f, 0.0f, 0.5f, 3.0f};
float ExpOutputArray_1[2*S_DEF] = {0, 0, 1, 0, 3, 3 ,1, 3};
int Observation_1 = 2;
	
//Use with hmm2
//float InputArray_2[2*S_DEF] = {0.400000, 0.400000, 0.100000, 0.100000, 2, 0, 1, 0};
float InputArray_2[2*S_DEF] = {0.400000f, 2.0f, 0.400000f, 0.0f, 0.100000f, 1, 0.100000f, 0};
int Observation_2 = 1;
float ExpOutputArray_2[2*S_DEF] = {0.078125, 0.312500, 0.109375, 0.500000, 1, 0 ,1, 0};

//Use with hmm3
//float InputArray_3[2*S_DEF] = {0.66, 0.33, 0.001, 0.99, 1, 2, 1, 2};
float InputArray_3[2*S_DEF] = {0.66f, 1.0f, 0.33f, 2.0f, 0.001f, 1.0f, 0.99f, 2.0f};
int Observation_3 = 0;
//Should not be able to produce output

#endif